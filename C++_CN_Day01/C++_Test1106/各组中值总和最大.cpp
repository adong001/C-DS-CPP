#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
//
//牛牛举办了一次编程比赛, 参加比赛的有3*n个选手, 每个选手都有一个水平值a_i.现在要将这些选手进行组队, 
//一共组成n个队伍, 即每个队伍3人.牛牛发现队伍的水平值等于该队伍队员中第二高水平值。
//例如 :
//一个队伍三个队员的水平值分别是3, 3, 3.那么队伍的水平值是3
//一个队伍三个队员的水平值分别是3, 2, 3.那么队伍的水平值是3
//一个队伍三个队员的水平值分别是1, 5, 2.那么队伍的水平值是2
//为了让比赛更有看点, 牛牛想安排队伍使所有队伍的水平值总和最大。
//如样例所示 :
//如果牛牛把6个队员划分到两个队伍
//如果方案为 :
//team1 : {1, 2, 5}, team2 : {5, 5, 8}, 这时候水平值总和为7.
//而如果方案为 :
//team1 : {2, 5, 8}, team2 : {1, 5, 5}, 这时候水平值总和为10.
//没有比总和为10更大的方案, 所以输出10.
//
// 输入描述 :
//输入的第一行为一个正整数n(1 ≤ n ≤ 10 ^ 5)
//第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10 ^ 9), 表示每个参赛选手的水平值.
//
//
//输出描述 :
//输出一个整数表示所有队伍的水平值总和最大值.
//
//示例1
//
//
//输入
//2
//5 2 8 5 1 5
//
//
//输出
//10
//简单分析一下，求各组中间值的最大和就是使所有组的中间值尽可能最大
//----》所以，采用贪心算法:
//1. 先排个序：例如一列数：{1,3,6,8,10,10,15,17,19}(题目中要求3*n个数)
//2.要使各组最最中间的数最大，那么他的左边就得有一个恰好比它大一点的值，就是排好序的右边那个
//  所以每组中间值取排序好的数组的下标为 3*n-2、3*n-4、、、、  
//3.利用上面的公式-->{x, 17，19}、{y, 10，15 }、{z, 8，10}，xyz随便，与结果无关，
//4.所有组中间值的和最大为 17 + 10 + 8 = 35

long long Max_Mid_Sum()
{
	vector<long long>ar;
	long long Max_sum = 0;
	int n = 2;//组数
	cin >> n;
	int i, j;
	ar.resize(3 * n);
	for (i = 0; i < 3 * n; i++)
	{
		cin >> ar[i];
		for (int k = i, j = i - 1; j >= 0; j--)
		{
			if (ar[k] < ar[j])
			{
				long long tmp = ar[k];
				ar[k] = ar[j];
				ar[j] = tmp;
				k = j;
			}
		}
	}
	for (int i = 2, j = 0; j < n; i += 2, j++)
	{
		Max_sum += ar[3 * n - i];
	}
	return Max_sum;
}


int main()
{
	cout << Max_Mid_Sum();
	system("pause");
	return 0;
}